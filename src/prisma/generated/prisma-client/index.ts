// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  annotation: (where?: AnnotationWhereInput) => Promise<boolean>;
  point: (where?: PointWhereInput) => Promise<boolean>;
  project: (where?: ProjectWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  annotation: (where: AnnotationWhereUniqueInput) => AnnotationNullablePromise;
  annotations: (args?: {
    where?: AnnotationWhereInput;
    orderBy?: AnnotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Annotation>;
  annotationsConnection: (args?: {
    where?: AnnotationWhereInput;
    orderBy?: AnnotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AnnotationConnectionPromise;
  point: (where: PointWhereUniqueInput) => PointNullablePromise;
  points: (args?: {
    where?: PointWhereInput;
    orderBy?: PointOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Point>;
  pointsConnection: (args?: {
    where?: PointWhereInput;
    orderBy?: PointOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PointConnectionPromise;
  project: (where: ProjectWhereUniqueInput) => ProjectNullablePromise;
  projects: (args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Project>;
  projectsConnection: (args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProjectConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAnnotation: (data: AnnotationCreateInput) => AnnotationPromise;
  updateAnnotation: (args: {
    data: AnnotationUpdateInput;
    where: AnnotationWhereUniqueInput;
  }) => AnnotationPromise;
  updateManyAnnotations: (args: {
    data: AnnotationUpdateManyMutationInput;
    where?: AnnotationWhereInput;
  }) => BatchPayloadPromise;
  upsertAnnotation: (args: {
    where: AnnotationWhereUniqueInput;
    create: AnnotationCreateInput;
    update: AnnotationUpdateInput;
  }) => AnnotationPromise;
  deleteAnnotation: (where: AnnotationWhereUniqueInput) => AnnotationPromise;
  deleteManyAnnotations: (where?: AnnotationWhereInput) => BatchPayloadPromise;
  createPoint: (data: PointCreateInput) => PointPromise;
  updatePoint: (args: {
    data: PointUpdateInput;
    where: PointWhereUniqueInput;
  }) => PointPromise;
  updateManyPoints: (args: {
    data: PointUpdateManyMutationInput;
    where?: PointWhereInput;
  }) => BatchPayloadPromise;
  upsertPoint: (args: {
    where: PointWhereUniqueInput;
    create: PointCreateInput;
    update: PointUpdateInput;
  }) => PointPromise;
  deletePoint: (where: PointWhereUniqueInput) => PointPromise;
  deleteManyPoints: (where?: PointWhereInput) => BatchPayloadPromise;
  createProject: (data: ProjectCreateInput) => ProjectPromise;
  updateProject: (args: {
    data: ProjectUpdateInput;
    where: ProjectWhereUniqueInput;
  }) => ProjectPromise;
  updateManyProjects: (args: {
    data: ProjectUpdateManyMutationInput;
    where?: ProjectWhereInput;
  }) => BatchPayloadPromise;
  upsertProject: (args: {
    where: ProjectWhereUniqueInput;
    create: ProjectCreateInput;
    update: ProjectUpdateInput;
  }) => ProjectPromise;
  deleteProject: (where: ProjectWhereUniqueInput) => ProjectPromise;
  deleteManyProjects: (where?: ProjectWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  annotation: (
    where?: AnnotationSubscriptionWhereInput
  ) => AnnotationSubscriptionPayloadSubscription;
  point: (
    where?: PointSubscriptionWhereInput
  ) => PointSubscriptionPayloadSubscription;
  project: (
    where?: ProjectSubscriptionWhereInput
  ) => ProjectSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ProjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "thumbnail_ASC"
  | "thumbnail_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type AnnotationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "isLeaf_ASC"
  | "isLeaf_DESC";

export type PointOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "color_ASC"
  | "color_DESC"
  | "size_ASC"
  | "size_DESC"
  | "description_ASC"
  | "description_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "password_ASC"
  | "password_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface PointUpdateWithoutProjectDataInput {
  name?: Maybe<String>;
  parent?: Maybe<AnnotationUpdateOneWithoutPointsInput>;
  coordinate?: Maybe<CoordinateUpdateOneRequiredInput>;
  color?: Maybe<String>;
  size?: Maybe<Int>;
  description?: Maybe<String>;
}

export type AnnotationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AnnotationUpdateManyWithoutParentInput {
  create?: Maybe<
    AnnotationCreateWithoutParentInput[] | AnnotationCreateWithoutParentInput
  >;
  delete?: Maybe<AnnotationWhereUniqueInput[] | AnnotationWhereUniqueInput>;
  connect?: Maybe<AnnotationWhereUniqueInput[] | AnnotationWhereUniqueInput>;
  set?: Maybe<AnnotationWhereUniqueInput[] | AnnotationWhereUniqueInput>;
  disconnect?: Maybe<AnnotationWhereUniqueInput[] | AnnotationWhereUniqueInput>;
  update?: Maybe<
    | AnnotationUpdateWithWhereUniqueWithoutParentInput[]
    | AnnotationUpdateWithWhereUniqueWithoutParentInput
  >;
  upsert?: Maybe<
    | AnnotationUpsertWithWhereUniqueWithoutParentInput[]
    | AnnotationUpsertWithWhereUniqueWithoutParentInput
  >;
  deleteMany?: Maybe<AnnotationScalarWhereInput[] | AnnotationScalarWhereInput>;
  updateMany?: Maybe<
    | AnnotationUpdateManyWithWhereNestedInput[]
    | AnnotationUpdateManyWithWhereNestedInput
  >;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  projects_some?: Maybe<ProjectWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface AnnotationUpdateWithWhereUniqueWithoutParentInput {
  where: AnnotationWhereUniqueInput;
  data: AnnotationUpdateWithoutParentDataInput;
}

export interface PointWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  parent?: Maybe<AnnotationWhereInput>;
  project?: Maybe<ProjectWhereInput>;
  coordinate?: Maybe<CoordinateWhereInput>;
  color?: Maybe<String>;
  color_not?: Maybe<String>;
  color_in?: Maybe<String[] | String>;
  color_not_in?: Maybe<String[] | String>;
  color_lt?: Maybe<String>;
  color_lte?: Maybe<String>;
  color_gt?: Maybe<String>;
  color_gte?: Maybe<String>;
  color_contains?: Maybe<String>;
  color_not_contains?: Maybe<String>;
  color_starts_with?: Maybe<String>;
  color_not_starts_with?: Maybe<String>;
  color_ends_with?: Maybe<String>;
  color_not_ends_with?: Maybe<String>;
  size?: Maybe<Int>;
  size_not?: Maybe<Int>;
  size_in?: Maybe<Int[] | Int>;
  size_not_in?: Maybe<Int[] | Int>;
  size_lt?: Maybe<Int>;
  size_lte?: Maybe<Int>;
  size_gt?: Maybe<Int>;
  size_gte?: Maybe<Int>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<PointWhereInput[] | PointWhereInput>;
}

export interface AnnotationCreateWithoutGroupsInput {
  id?: Maybe<ID_Input>;
  name: String;
  project?: Maybe<ProjectCreateOneWithoutAnnotationsInput>;
  parent?: Maybe<AnnotationCreateOneWithoutGroupsInput>;
  points?: Maybe<PointCreateManyWithoutParentInput>;
  isLeaf?: Maybe<Boolean>;
}

export interface AnnotationUpdateManyMutationInput {
  name?: Maybe<String>;
  isLeaf?: Maybe<Boolean>;
}

export interface CoordinateCreateOneInput {
  create?: Maybe<CoordinateCreateInput>;
}

export interface AnnotationUpdateWithoutParentDataInput {
  name?: Maybe<String>;
  project?: Maybe<ProjectUpdateOneWithoutAnnotationsInput>;
  groups?: Maybe<AnnotationUpdateManyWithoutParentInput>;
  points?: Maybe<PointUpdateManyWithoutParentInput>;
  isLeaf?: Maybe<Boolean>;
}

export interface CoordinateCreateInput {
  lng: Float;
  lat: Float;
}

export interface ProjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProjectWhereInput>;
  AND?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
}

export interface AnnotationUpdateInput {
  name?: Maybe<String>;
  project?: Maybe<ProjectUpdateOneWithoutAnnotationsInput>;
  groups?: Maybe<AnnotationUpdateManyWithoutParentInput>;
  parent?: Maybe<AnnotationUpdateOneWithoutGroupsInput>;
  points?: Maybe<PointUpdateManyWithoutParentInput>;
  isLeaf?: Maybe<Boolean>;
}

export interface PointSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PointWhereInput>;
  AND?: Maybe<PointSubscriptionWhereInput[] | PointSubscriptionWhereInput>;
}

export interface ProjectUpdateOneWithoutAnnotationsInput {
  create?: Maybe<ProjectCreateWithoutAnnotationsInput>;
  update?: Maybe<ProjectUpdateWithoutAnnotationsDataInput>;
  upsert?: Maybe<ProjectUpsertWithoutAnnotationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface UserUpdateManyMutationInput {
  password?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
}

export interface ProjectUpdateWithoutAnnotationsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredWithoutProjectsInput>;
  thumbnail?: Maybe<String>;
  points?: Maybe<PointUpdateManyWithoutProjectInput>;
}

export interface ProjectUpdateManyWithWhereNestedInput {
  where: ProjectScalarWhereInput;
  data: ProjectUpdateManyDataInput;
}

export interface UserUpdateOneRequiredWithoutProjectsInput {
  create?: Maybe<UserCreateWithoutProjectsInput>;
  update?: Maybe<UserUpdateWithoutProjectsDataInput>;
  upsert?: Maybe<UserUpsertWithoutProjectsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ProjectUpsertWithWhereUniqueWithoutAuthorInput {
  where: ProjectWhereUniqueInput;
  update: ProjectUpdateWithoutAuthorDataInput;
  create: ProjectCreateWithoutAuthorInput;
}

export interface UserUpdateWithoutProjectsDataInput {
  password?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
}

export type PointWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpsertWithoutProjectsInput {
  update: UserUpdateWithoutProjectsDataInput;
  create: UserCreateWithoutProjectsInput;
}

export interface ProjectUpdateManyWithoutAuthorInput {
  create?: Maybe<
    ProjectCreateWithoutAuthorInput[] | ProjectCreateWithoutAuthorInput
  >;
  delete?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  connect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  set?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  disconnect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  update?: Maybe<
    | ProjectUpdateWithWhereUniqueWithoutAuthorInput[]
    | ProjectUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | ProjectUpsertWithWhereUniqueWithoutAuthorInput[]
    | ProjectUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  updateMany?: Maybe<
    | ProjectUpdateManyWithWhereNestedInput[]
    | ProjectUpdateManyWithWhereNestedInput
  >;
}

export interface PointUpdateManyWithoutProjectInput {
  create?: Maybe<
    PointCreateWithoutProjectInput[] | PointCreateWithoutProjectInput
  >;
  delete?: Maybe<PointWhereUniqueInput[] | PointWhereUniqueInput>;
  connect?: Maybe<PointWhereUniqueInput[] | PointWhereUniqueInput>;
  set?: Maybe<PointWhereUniqueInput[] | PointWhereUniqueInput>;
  disconnect?: Maybe<PointWhereUniqueInput[] | PointWhereUniqueInput>;
  update?: Maybe<
    | PointUpdateWithWhereUniqueWithoutProjectInput[]
    | PointUpdateWithWhereUniqueWithoutProjectInput
  >;
  upsert?: Maybe<
    | PointUpsertWithWhereUniqueWithoutProjectInput[]
    | PointUpsertWithWhereUniqueWithoutProjectInput
  >;
  deleteMany?: Maybe<PointScalarWhereInput[] | PointScalarWhereInput>;
  updateMany?: Maybe<
    PointUpdateManyWithWhereNestedInput[] | PointUpdateManyWithWhereNestedInput
  >;
}

export type ProjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PointUpdateWithWhereUniqueWithoutProjectInput {
  where: PointWhereUniqueInput;
  data: PointUpdateWithoutProjectDataInput;
}

export interface ProjectCreateManyWithoutAuthorInput {
  create?: Maybe<
    ProjectCreateWithoutAuthorInput[] | ProjectCreateWithoutAuthorInput
  >;
  connect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
}

export interface PointUpdateInput {
  name?: Maybe<String>;
  parent?: Maybe<AnnotationUpdateOneWithoutPointsInput>;
  project?: Maybe<ProjectUpdateOneWithoutPointsInput>;
  coordinate?: Maybe<CoordinateUpdateOneRequiredInput>;
  color?: Maybe<String>;
  size?: Maybe<Int>;
  description?: Maybe<String>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface AnnotationUpdateOneWithoutPointsInput {
  create?: Maybe<AnnotationCreateWithoutPointsInput>;
  update?: Maybe<AnnotationUpdateWithoutPointsDataInput>;
  upsert?: Maybe<AnnotationUpsertWithoutPointsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AnnotationWhereUniqueInput>;
}

export interface ProjectUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredWithoutProjectsInput>;
  thumbnail?: Maybe<String>;
  annotations?: Maybe<AnnotationUpdateManyWithoutProjectInput>;
  points?: Maybe<PointUpdateManyWithoutProjectInput>;
}

export interface AnnotationUpdateWithoutPointsDataInput {
  name?: Maybe<String>;
  project?: Maybe<ProjectUpdateOneWithoutAnnotationsInput>;
  groups?: Maybe<AnnotationUpdateManyWithoutParentInput>;
  parent?: Maybe<AnnotationUpdateOneWithoutGroupsInput>;
  isLeaf?: Maybe<Boolean>;
}

export interface PointUpdateManyMutationInput {
  name?: Maybe<String>;
  color?: Maybe<String>;
  size?: Maybe<Int>;
  description?: Maybe<String>;
}

export interface AnnotationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  project?: Maybe<ProjectWhereInput>;
  groups_some?: Maybe<AnnotationWhereInput>;
  parent?: Maybe<AnnotationWhereInput>;
  points_some?: Maybe<PointWhereInput>;
  isLeaf?: Maybe<Boolean>;
  isLeaf_not?: Maybe<Boolean>;
  AND?: Maybe<AnnotationWhereInput[] | AnnotationWhereInput>;
}

export interface AnnotationCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  project?: Maybe<ProjectCreateOneWithoutAnnotationsInput>;
  groups?: Maybe<AnnotationCreateManyWithoutParentInput>;
  parent?: Maybe<AnnotationCreateOneWithoutGroupsInput>;
  points?: Maybe<PointCreateManyWithoutParentInput>;
  isLeaf?: Maybe<Boolean>;
}

export interface CoordinateWhereInput {
  lng?: Maybe<Float>;
  lng_not?: Maybe<Float>;
  lng_in?: Maybe<Float[] | Float>;
  lng_not_in?: Maybe<Float[] | Float>;
  lng_lt?: Maybe<Float>;
  lng_lte?: Maybe<Float>;
  lng_gt?: Maybe<Float>;
  lng_gte?: Maybe<Float>;
  lat?: Maybe<Float>;
  lat_not?: Maybe<Float>;
  lat_in?: Maybe<Float[] | Float>;
  lat_not_in?: Maybe<Float[] | Float>;
  lat_lt?: Maybe<Float>;
  lat_lte?: Maybe<Float>;
  lat_gt?: Maybe<Float>;
  lat_gte?: Maybe<Float>;
  AND?: Maybe<CoordinateWhereInput[] | CoordinateWhereInput>;
}

export interface ProjectCreateWithoutAnnotationsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  author: UserCreateOneWithoutProjectsInput;
  thumbnail?: Maybe<String>;
  points?: Maybe<PointCreateManyWithoutProjectInput>;
}

export interface PointCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  parent?: Maybe<AnnotationCreateOneWithoutPointsInput>;
  project?: Maybe<ProjectCreateOneWithoutPointsInput>;
  coordinate: CoordinateCreateOneInput;
  color?: Maybe<String>;
  size?: Maybe<Int>;
  description?: Maybe<String>;
}

export interface UserCreateWithoutProjectsInput {
  id?: Maybe<ID_Input>;
  password: String;
  name: String;
  email: String;
}

export interface PointUpdateManyWithoutParentInput {
  create?: Maybe<
    PointCreateWithoutParentInput[] | PointCreateWithoutParentInput
  >;
  delete?: Maybe<PointWhereUniqueInput[] | PointWhereUniqueInput>;
  connect?: Maybe<PointWhereUniqueInput[] | PointWhereUniqueInput>;
  set?: Maybe<PointWhereUniqueInput[] | PointWhereUniqueInput>;
  disconnect?: Maybe<PointWhereUniqueInput[] | PointWhereUniqueInput>;
  update?: Maybe<
    | PointUpdateWithWhereUniqueWithoutParentInput[]
    | PointUpdateWithWhereUniqueWithoutParentInput
  >;
  upsert?: Maybe<
    | PointUpsertWithWhereUniqueWithoutParentInput[]
    | PointUpsertWithWhereUniqueWithoutParentInput
  >;
  deleteMany?: Maybe<PointScalarWhereInput[] | PointScalarWhereInput>;
  updateMany?: Maybe<
    PointUpdateManyWithWhereNestedInput[] | PointUpdateManyWithWhereNestedInput
  >;
}

export interface PointCreateWithoutProjectInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  parent?: Maybe<AnnotationCreateOneWithoutPointsInput>;
  coordinate: CoordinateCreateOneInput;
  color?: Maybe<String>;
  size?: Maybe<Int>;
  description?: Maybe<String>;
}

export interface PointUpdateWithWhereUniqueWithoutParentInput {
  where: PointWhereUniqueInput;
  data: PointUpdateWithoutParentDataInput;
}

export interface AnnotationCreateWithoutPointsInput {
  id?: Maybe<ID_Input>;
  name: String;
  project?: Maybe<ProjectCreateOneWithoutAnnotationsInput>;
  groups?: Maybe<AnnotationCreateManyWithoutParentInput>;
  parent?: Maybe<AnnotationCreateOneWithoutGroupsInput>;
  isLeaf?: Maybe<Boolean>;
}

export interface PointUpdateWithoutParentDataInput {
  name?: Maybe<String>;
  project?: Maybe<ProjectUpdateOneWithoutPointsInput>;
  coordinate?: Maybe<CoordinateUpdateOneRequiredInput>;
  color?: Maybe<String>;
  size?: Maybe<Int>;
  description?: Maybe<String>;
}

export interface AnnotationCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  name: String;
  project?: Maybe<ProjectCreateOneWithoutAnnotationsInput>;
  groups?: Maybe<AnnotationCreateManyWithoutParentInput>;
  points?: Maybe<PointCreateManyWithoutParentInput>;
  isLeaf?: Maybe<Boolean>;
}

export interface ProjectUpdateOneWithoutPointsInput {
  create?: Maybe<ProjectCreateWithoutPointsInput>;
  update?: Maybe<ProjectUpdateWithoutPointsDataInput>;
  upsert?: Maybe<ProjectUpsertWithoutPointsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface PointCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  project?: Maybe<ProjectCreateOneWithoutPointsInput>;
  coordinate: CoordinateCreateOneInput;
  color?: Maybe<String>;
  size?: Maybe<Int>;
  description?: Maybe<String>;
}

export interface ProjectUpdateWithoutPointsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredWithoutProjectsInput>;
  thumbnail?: Maybe<String>;
  annotations?: Maybe<AnnotationUpdateManyWithoutProjectInput>;
}

export interface ProjectCreateWithoutPointsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  author: UserCreateOneWithoutProjectsInput;
  thumbnail?: Maybe<String>;
  annotations?: Maybe<AnnotationCreateManyWithoutProjectInput>;
}

export interface AnnotationUpdateManyWithoutProjectInput {
  create?: Maybe<
    AnnotationCreateWithoutProjectInput[] | AnnotationCreateWithoutProjectInput
  >;
  delete?: Maybe<AnnotationWhereUniqueInput[] | AnnotationWhereUniqueInput>;
  connect?: Maybe<AnnotationWhereUniqueInput[] | AnnotationWhereUniqueInput>;
  set?: Maybe<AnnotationWhereUniqueInput[] | AnnotationWhereUniqueInput>;
  disconnect?: Maybe<AnnotationWhereUniqueInput[] | AnnotationWhereUniqueInput>;
  update?: Maybe<
    | AnnotationUpdateWithWhereUniqueWithoutProjectInput[]
    | AnnotationUpdateWithWhereUniqueWithoutProjectInput
  >;
  upsert?: Maybe<
    | AnnotationUpsertWithWhereUniqueWithoutProjectInput[]
    | AnnotationUpsertWithWhereUniqueWithoutProjectInput
  >;
  deleteMany?: Maybe<AnnotationScalarWhereInput[] | AnnotationScalarWhereInput>;
  updateMany?: Maybe<
    | AnnotationUpdateManyWithWhereNestedInput[]
    | AnnotationUpdateManyWithWhereNestedInput
  >;
}

export interface AnnotationCreateWithoutProjectInput {
  id?: Maybe<ID_Input>;
  name: String;
  groups?: Maybe<AnnotationCreateManyWithoutParentInput>;
  parent?: Maybe<AnnotationCreateOneWithoutGroupsInput>;
  points?: Maybe<PointCreateManyWithoutParentInput>;
  isLeaf?: Maybe<Boolean>;
}

export interface AnnotationUpdateWithWhereUniqueWithoutProjectInput {
  where: AnnotationWhereUniqueInput;
  data: AnnotationUpdateWithoutProjectDataInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface AnnotationUpdateWithoutProjectDataInput {
  name?: Maybe<String>;
  groups?: Maybe<AnnotationUpdateManyWithoutParentInput>;
  parent?: Maybe<AnnotationUpdateOneWithoutGroupsInput>;
  points?: Maybe<PointUpdateManyWithoutParentInput>;
  isLeaf?: Maybe<Boolean>;
}

export interface AnnotationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AnnotationWhereInput>;
  AND?: Maybe<
    AnnotationSubscriptionWhereInput[] | AnnotationSubscriptionWhereInput
  >;
}

export interface AnnotationUpdateOneWithoutGroupsInput {
  create?: Maybe<AnnotationCreateWithoutGroupsInput>;
  update?: Maybe<AnnotationUpdateWithoutGroupsDataInput>;
  upsert?: Maybe<AnnotationUpsertWithoutGroupsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AnnotationWhereUniqueInput>;
}

export interface ProjectScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  thumbnail?: Maybe<String>;
  thumbnail_not?: Maybe<String>;
  thumbnail_in?: Maybe<String[] | String>;
  thumbnail_not_in?: Maybe<String[] | String>;
  thumbnail_lt?: Maybe<String>;
  thumbnail_lte?: Maybe<String>;
  thumbnail_gt?: Maybe<String>;
  thumbnail_gte?: Maybe<String>;
  thumbnail_contains?: Maybe<String>;
  thumbnail_not_contains?: Maybe<String>;
  thumbnail_starts_with?: Maybe<String>;
  thumbnail_not_starts_with?: Maybe<String>;
  thumbnail_ends_with?: Maybe<String>;
  thumbnail_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  OR?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  NOT?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
}

export interface AnnotationUpdateWithoutGroupsDataInput {
  name?: Maybe<String>;
  project?: Maybe<ProjectUpdateOneWithoutAnnotationsInput>;
  parent?: Maybe<AnnotationUpdateOneWithoutGroupsInput>;
  points?: Maybe<PointUpdateManyWithoutParentInput>;
  isLeaf?: Maybe<Boolean>;
}

export interface ProjectUpdateWithWhereUniqueWithoutAuthorInput {
  where: ProjectWhereUniqueInput;
  data: ProjectUpdateWithoutAuthorDataInput;
}

export interface AnnotationUpsertWithoutGroupsInput {
  update: AnnotationUpdateWithoutGroupsDataInput;
  create: AnnotationCreateWithoutGroupsInput;
}

export interface ProjectCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  thumbnail?: Maybe<String>;
  annotations?: Maybe<AnnotationCreateManyWithoutProjectInput>;
  points?: Maybe<PointCreateManyWithoutProjectInput>;
}

export interface AnnotationUpsertWithWhereUniqueWithoutProjectInput {
  where: AnnotationWhereUniqueInput;
  update: AnnotationUpdateWithoutProjectDataInput;
  create: AnnotationCreateWithoutProjectInput;
}

export interface ProjectUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  thumbnail?: Maybe<String>;
}

export interface AnnotationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  isLeaf?: Maybe<Boolean>;
  isLeaf_not?: Maybe<Boolean>;
  AND?: Maybe<AnnotationScalarWhereInput[] | AnnotationScalarWhereInput>;
  OR?: Maybe<AnnotationScalarWhereInput[] | AnnotationScalarWhereInput>;
  NOT?: Maybe<AnnotationScalarWhereInput[] | AnnotationScalarWhereInput>;
}

export interface UserCreateOneWithoutProjectsInput {
  create?: Maybe<UserCreateWithoutProjectsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface AnnotationUpdateManyWithWhereNestedInput {
  where: AnnotationScalarWhereInput;
  data: AnnotationUpdateManyDataInput;
}

export interface AnnotationCreateOneWithoutPointsInput {
  create?: Maybe<AnnotationCreateWithoutPointsInput>;
  connect?: Maybe<AnnotationWhereUniqueInput>;
}

export interface AnnotationUpdateManyDataInput {
  name?: Maybe<String>;
  isLeaf?: Maybe<Boolean>;
}

export interface PointCreateManyWithoutParentInput {
  create?: Maybe<
    PointCreateWithoutParentInput[] | PointCreateWithoutParentInput
  >;
  connect?: Maybe<PointWhereUniqueInput[] | PointWhereUniqueInput>;
}

export interface ProjectUpsertWithoutPointsInput {
  update: ProjectUpdateWithoutPointsDataInput;
  create: ProjectCreateWithoutPointsInput;
}

export interface AnnotationCreateManyWithoutProjectInput {
  create?: Maybe<
    AnnotationCreateWithoutProjectInput[] | AnnotationCreateWithoutProjectInput
  >;
  connect?: Maybe<AnnotationWhereUniqueInput[] | AnnotationWhereUniqueInput>;
}

export interface CoordinateUpdateOneRequiredInput {
  create?: Maybe<CoordinateCreateInput>;
  update?: Maybe<CoordinateUpdateDataInput>;
  upsert?: Maybe<CoordinateUpsertNestedInput>;
}

export interface ProjectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  author?: Maybe<UserWhereInput>;
  thumbnail?: Maybe<String>;
  thumbnail_not?: Maybe<String>;
  thumbnail_in?: Maybe<String[] | String>;
  thumbnail_not_in?: Maybe<String[] | String>;
  thumbnail_lt?: Maybe<String>;
  thumbnail_lte?: Maybe<String>;
  thumbnail_gt?: Maybe<String>;
  thumbnail_gte?: Maybe<String>;
  thumbnail_contains?: Maybe<String>;
  thumbnail_not_contains?: Maybe<String>;
  thumbnail_starts_with?: Maybe<String>;
  thumbnail_not_starts_with?: Maybe<String>;
  thumbnail_ends_with?: Maybe<String>;
  thumbnail_not_ends_with?: Maybe<String>;
  annotations_some?: Maybe<AnnotationWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  points_some?: Maybe<PointWhereInput>;
  AND?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
}

export interface CoordinateUpdateDataInput {
  lng?: Maybe<Float>;
  lat?: Maybe<Float>;
}

export interface ProjectUpdateWithoutAuthorDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  thumbnail?: Maybe<String>;
  annotations?: Maybe<AnnotationUpdateManyWithoutProjectInput>;
  points?: Maybe<PointUpdateManyWithoutProjectInput>;
}

export interface CoordinateUpsertNestedInput {
  update: CoordinateUpdateDataInput;
  create: CoordinateCreateInput;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  password: String;
  name: String;
  email: String;
  projects?: Maybe<ProjectCreateManyWithoutAuthorInput>;
}

export interface PointUpsertWithWhereUniqueWithoutParentInput {
  where: PointWhereUniqueInput;
  update: PointUpdateWithoutParentDataInput;
  create: PointCreateWithoutParentInput;
}

export interface ProjectCreateOneWithoutAnnotationsInput {
  create?: Maybe<ProjectCreateWithoutAnnotationsInput>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface PointScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  color?: Maybe<String>;
  color_not?: Maybe<String>;
  color_in?: Maybe<String[] | String>;
  color_not_in?: Maybe<String[] | String>;
  color_lt?: Maybe<String>;
  color_lte?: Maybe<String>;
  color_gt?: Maybe<String>;
  color_gte?: Maybe<String>;
  color_contains?: Maybe<String>;
  color_not_contains?: Maybe<String>;
  color_starts_with?: Maybe<String>;
  color_not_starts_with?: Maybe<String>;
  color_ends_with?: Maybe<String>;
  color_not_ends_with?: Maybe<String>;
  size?: Maybe<Int>;
  size_not?: Maybe<Int>;
  size_in?: Maybe<Int[] | Int>;
  size_not_in?: Maybe<Int[] | Int>;
  size_lt?: Maybe<Int>;
  size_lte?: Maybe<Int>;
  size_gt?: Maybe<Int>;
  size_gte?: Maybe<Int>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<PointScalarWhereInput[] | PointScalarWhereInput>;
  OR?: Maybe<PointScalarWhereInput[] | PointScalarWhereInput>;
  NOT?: Maybe<PointScalarWhereInput[] | PointScalarWhereInput>;
}

export interface AnnotationCreateManyWithoutParentInput {
  create?: Maybe<
    AnnotationCreateWithoutParentInput[] | AnnotationCreateWithoutParentInput
  >;
  connect?: Maybe<AnnotationWhereUniqueInput[] | AnnotationWhereUniqueInput>;
}

export interface PointUpdateManyWithWhereNestedInput {
  where: PointScalarWhereInput;
  data: PointUpdateManyDataInput;
}

export interface AnnotationCreateOneWithoutGroupsInput {
  create?: Maybe<AnnotationCreateWithoutGroupsInput>;
  connect?: Maybe<AnnotationWhereUniqueInput>;
}

export interface PointUpdateManyDataInput {
  name?: Maybe<String>;
  color?: Maybe<String>;
  size?: Maybe<Int>;
  description?: Maybe<String>;
}

export interface UserUpdateInput {
  password?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  projects?: Maybe<ProjectUpdateManyWithoutAuthorInput>;
}

export interface ProjectUpsertWithoutAnnotationsInput {
  update: ProjectUpdateWithoutAnnotationsDataInput;
  create: ProjectCreateWithoutAnnotationsInput;
}

export interface PointUpsertWithWhereUniqueWithoutProjectInput {
  where: PointWhereUniqueInput;
  update: PointUpdateWithoutProjectDataInput;
  create: PointCreateWithoutProjectInput;
}

export interface AnnotationUpsertWithoutPointsInput {
  update: AnnotationUpdateWithoutPointsDataInput;
  create: AnnotationCreateWithoutPointsInput;
}

export interface AnnotationUpsertWithWhereUniqueWithoutParentInput {
  where: AnnotationWhereUniqueInput;
  update: AnnotationUpdateWithoutParentDataInput;
  create: AnnotationCreateWithoutParentInput;
}

export interface ProjectCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  author: UserCreateOneWithoutProjectsInput;
  thumbnail?: Maybe<String>;
  annotations?: Maybe<AnnotationCreateManyWithoutProjectInput>;
  points?: Maybe<PointCreateManyWithoutProjectInput>;
}

export interface ProjectUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  thumbnail?: Maybe<String>;
}

export interface ProjectCreateOneWithoutPointsInput {
  create?: Maybe<ProjectCreateWithoutPointsInput>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface PointCreateManyWithoutProjectInput {
  create?: Maybe<
    PointCreateWithoutProjectInput[] | PointCreateWithoutProjectInput
  >;
  connect?: Maybe<PointWhereUniqueInput[] | PointWhereUniqueInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  password: String;
  name: String;
  email: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  email: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AnnotationEdge {
  node: Annotation;
  cursor: String;
}

export interface AnnotationEdgePromise
  extends Promise<AnnotationEdge>,
    Fragmentable {
  node: <T = AnnotationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AnnotationEdgeSubscription
  extends Promise<AsyncIterator<AnnotationEdge>>,
    Fragmentable {
  node: <T = AnnotationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PointPreviousValues {
  id: ID_Output;
  name: String;
  color: String;
  size: Int;
  description?: String;
}

export interface PointPreviousValuesPromise
  extends Promise<PointPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  color: () => Promise<String>;
  size: () => Promise<Int>;
  description: () => Promise<String>;
}

export interface PointPreviousValuesSubscription
  extends Promise<AsyncIterator<PointPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  color: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ProjectPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  thumbnail?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ProjectPreviousValuesPromise
  extends Promise<ProjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  thumbnail: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ProjectPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AnnotationConnection {
  pageInfo: PageInfo;
  edges: AnnotationEdge[];
}

export interface AnnotationConnectionPromise
  extends Promise<AnnotationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AnnotationEdge>>() => T;
  aggregate: <T = AggregateAnnotationPromise>() => T;
}

export interface AnnotationConnectionSubscription
  extends Promise<AsyncIterator<AnnotationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AnnotationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAnnotationSubscription>() => T;
}

export interface ProjectSubscriptionPayload {
  mutation: MutationType;
  node: Project;
  updatedFields: String[];
  previousValues: ProjectPreviousValues;
}

export interface ProjectSubscriptionPayloadPromise
  extends Promise<ProjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectPreviousValuesPromise>() => T;
}

export interface ProjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Coordinate {
  lng: Float;
  lat: Float;
}

export interface CoordinatePromise extends Promise<Coordinate>, Fragmentable {
  lng: () => Promise<Float>;
  lat: () => Promise<Float>;
}

export interface CoordinateSubscription
  extends Promise<AsyncIterator<Coordinate>>,
    Fragmentable {
  lng: () => Promise<AsyncIterator<Float>>;
  lat: () => Promise<AsyncIterator<Float>>;
}

export interface CoordinateNullablePromise
  extends Promise<Coordinate | null>,
    Fragmentable {
  lng: () => Promise<Float>;
  lat: () => Promise<Float>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface Point {
  id: ID_Output;
  name: String;
  coordinate: Coordinate;
  color: String;
  size: Int;
  description?: String;
}

export interface PointPromise extends Promise<Point>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  parent: <T = AnnotationPromise>() => T;
  project: <T = ProjectPromise>() => T;
  coordinate: <T = CoordinatePromise>() => T;
  color: () => Promise<String>;
  size: () => Promise<Int>;
  description: () => Promise<String>;
}

export interface PointSubscription
  extends Promise<AsyncIterator<Point>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  parent: <T = AnnotationSubscription>() => T;
  project: <T = ProjectSubscription>() => T;
  coordinate: <T = CoordinateSubscription>() => T;
  color: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface PointNullablePromise
  extends Promise<Point | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  parent: <T = AnnotationPromise>() => T;
  project: <T = ProjectPromise>() => T;
  coordinate: <T = CoordinatePromise>() => T;
  color: () => Promise<String>;
  size: () => Promise<Int>;
  description: () => Promise<String>;
}

export interface ProjectEdge {
  node: Project;
  cursor: String;
}

export interface ProjectEdgePromise extends Promise<ProjectEdge>, Fragmentable {
  node: <T = ProjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectEdgeSubscription
  extends Promise<AsyncIterator<ProjectEdge>>,
    Fragmentable {
  node: <T = ProjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Project {
  id: ID_Output;
  name: String;
  description?: String;
  thumbnail?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ProjectPromise extends Promise<Project>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  author: <T = UserPromise>() => T;
  thumbnail: () => Promise<String>;
  annotations: <T = FragmentableArray<Annotation>>(args?: {
    where?: AnnotationWhereInput;
    orderBy?: AnnotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  points: <T = FragmentableArray<Point>>(args?: {
    where?: PointWhereInput;
    orderBy?: PointOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProjectSubscription
  extends Promise<AsyncIterator<Project>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
  thumbnail: () => Promise<AsyncIterator<String>>;
  annotations: <T = Promise<AsyncIterator<AnnotationSubscription>>>(args?: {
    where?: AnnotationWhereInput;
    orderBy?: AnnotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  points: <T = Promise<AsyncIterator<PointSubscription>>>(args?: {
    where?: PointWhereInput;
    orderBy?: PointOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProjectNullablePromise
  extends Promise<Project | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  author: <T = UserPromise>() => T;
  thumbnail: () => Promise<String>;
  annotations: <T = FragmentableArray<Annotation>>(args?: {
    where?: AnnotationWhereInput;
    orderBy?: AnnotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  points: <T = FragmentableArray<Point>>(args?: {
    where?: PointWhereInput;
    orderBy?: PointOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregatePoint {
  count: Int;
}

export interface AggregatePointPromise
  extends Promise<AggregatePoint>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePointSubscription
  extends Promise<AsyncIterator<AggregatePoint>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Annotation {
  id: ID_Output;
  name: String;
  isLeaf: Boolean;
}

export interface AnnotationPromise extends Promise<Annotation>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  project: <T = ProjectPromise>() => T;
  groups: <T = FragmentableArray<Annotation>>(args?: {
    where?: AnnotationWhereInput;
    orderBy?: AnnotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = AnnotationPromise>() => T;
  points: <T = FragmentableArray<Point>>(args?: {
    where?: PointWhereInput;
    orderBy?: PointOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isLeaf: () => Promise<Boolean>;
}

export interface AnnotationSubscription
  extends Promise<AsyncIterator<Annotation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  project: <T = ProjectSubscription>() => T;
  groups: <T = Promise<AsyncIterator<AnnotationSubscription>>>(args?: {
    where?: AnnotationWhereInput;
    orderBy?: AnnotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = AnnotationSubscription>() => T;
  points: <T = Promise<AsyncIterator<PointSubscription>>>(args?: {
    where?: PointWhereInput;
    orderBy?: PointOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isLeaf: () => Promise<AsyncIterator<Boolean>>;
}

export interface AnnotationNullablePromise
  extends Promise<Annotation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  project: <T = ProjectPromise>() => T;
  groups: <T = FragmentableArray<Annotation>>(args?: {
    where?: AnnotationWhereInput;
    orderBy?: AnnotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = AnnotationPromise>() => T;
  points: <T = FragmentableArray<Point>>(args?: {
    where?: PointWhereInput;
    orderBy?: PointOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isLeaf: () => Promise<Boolean>;
}

export interface PointConnection {
  pageInfo: PageInfo;
  edges: PointEdge[];
}

export interface PointConnectionPromise
  extends Promise<PointConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PointEdge>>() => T;
  aggregate: <T = AggregatePointPromise>() => T;
}

export interface PointConnectionSubscription
  extends Promise<AsyncIterator<PointConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PointEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePointSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PointSubscriptionPayload {
  mutation: MutationType;
  node: Point;
  updatedFields: String[];
  previousValues: PointPreviousValues;
}

export interface PointSubscriptionPayloadPromise
  extends Promise<PointSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PointPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PointPreviousValuesPromise>() => T;
}

export interface PointSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PointSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PointSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PointPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  password: String;
  name: String;
  email: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  projects: <T = FragmentableArray<Project>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  projects: <T = Promise<AsyncIterator<ProjectSubscription>>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  projects: <T = FragmentableArray<Project>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AnnotationPreviousValues {
  id: ID_Output;
  name: String;
  isLeaf: Boolean;
}

export interface AnnotationPreviousValuesPromise
  extends Promise<AnnotationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  isLeaf: () => Promise<Boolean>;
}

export interface AnnotationPreviousValuesSubscription
  extends Promise<AsyncIterator<AnnotationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  isLeaf: () => Promise<AsyncIterator<Boolean>>;
}

export interface AnnotationSubscriptionPayload {
  mutation: MutationType;
  node: Annotation;
  updatedFields: String[];
  previousValues: AnnotationPreviousValues;
}

export interface AnnotationSubscriptionPayloadPromise
  extends Promise<AnnotationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AnnotationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AnnotationPreviousValuesPromise>() => T;
}

export interface AnnotationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AnnotationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AnnotationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AnnotationPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AggregateAnnotation {
  count: Int;
}

export interface AggregateAnnotationPromise
  extends Promise<AggregateAnnotation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAnnotationSubscription
  extends Promise<AsyncIterator<AggregateAnnotation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PointEdge {
  node: Point;
  cursor: String;
}

export interface PointEdgePromise extends Promise<PointEdge>, Fragmentable {
  node: <T = PointPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PointEdgeSubscription
  extends Promise<AsyncIterator<PointEdge>>,
    Fragmentable {
  node: <T = PointSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectConnection {
  pageInfo: PageInfo;
  edges: ProjectEdge[];
}

export interface ProjectConnectionPromise
  extends Promise<ProjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectEdge>>() => T;
  aggregate: <T = AggregateProjectPromise>() => T;
}

export interface ProjectConnectionSubscription
  extends Promise<AsyncIterator<ProjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectSubscription>() => T;
}

export interface AggregateProject {
  count: Int;
}

export interface AggregateProjectPromise
  extends Promise<AggregateProject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectSubscription
  extends Promise<AsyncIterator<AggregateProject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Project",
    embedded: false
  },
  {
    name: "Annotation",
    embedded: false
  },
  {
    name: "Point",
    embedded: false
  },
  {
    name: "Coordinate",
    embedded: true
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SERVICE_SECRET"]}`
});
export const prisma = new Prisma();
